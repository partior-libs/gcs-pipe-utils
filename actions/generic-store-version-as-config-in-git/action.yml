name: 'Partior - Store version as config in Git'
description: 'Store version as config in Git'
inputs:
  yaml-store-path-key:
    description: 'Query Path to the stored configuration'
    required: true
    default: ''
  yaml-env-list-query-path:
    description: 'Query Path to the list of env'
    required: false
    default: artifact.packager.store-version.git.target-envs
  target-yaml-config-file:  
    description: 'Target yaml config to be updated'
    required: true
    default: ''
  create-if-new-config:  
    description: 'Create new file if target yaml file not found'
    required: false
    default: true
  target-repo:  
    description: 'Target repo where yaml is stored'
    required: true
    default: ''
  target-repo-ref:  
    description: 'Target repo ref to be updated'
    required: false
    default: 'main'
  artifact-base-name:  
    description: 'Artifact base name to be stored in yaml'
    required: true
    default: ''
  artifact-version:  
    description: 'Artifact version to be stored in yaml'
    required: true
    default: ''
  git-push:
    description: 'Flag to indicate if git push to be executed'
    required: false
    default: true
  pat-token:
    description: 'PAT token to push code'
    required: true
    default: ''
  search-list-match-value:
    description: 'Used only during list searching. Matching value from the object @@FOUND@@'
    required: false
    default: ''
  search-list-yaml-post-query:
    description: 'Used only during list searching. Must contain @@SEARCH@@ as list object reference'
    required: false
    default: ''
  target-multi-yaml-config-files:  
    description: 'Additional yaml files to be updated. Support comma delimited.'
    required: false
    default: ''
  strict-update:  
    description: 'If true, will fail if updating failed'
    required: false
    default: 'true'
  enable-auto-filter-target-ref:
    description: 'If true, will filter the target branch with major and minor from target-repo-ref'
    required: false
    default: 'false'
runs:
  using: "composite"
  steps:
    - name: Filter and Finalize Branch
      id: filter-branch
      shell: bash
      run: |
        # This script block determines the target branch reference.
        # It has two modes based on the 'enable-auto-filter-target-ref' input.

        if [[ "${{ inputs.enable-auto-filter-target-ref }}" == "true" ]]; then
          # MODE 1: Auto-filter to find a unique branch based on a version pattern.
          # This is useful for finding a release branch like 'release/25.1' when the source is 'release/25.1.x'.

          # Extract the base of the branch name (e.g., "refs/heads/hotfix/25.1.1" -> "hotfix/25.1")
          TARGET_FILTER_BRANCH_VERSION=$(echo "${{ inputs.target-repo-ref }}" | sed -E 's|([0-9]+\.[0-9]+)\.[0-9]+$|\1|' | sed -E 's|refs/heads/||')
          echo "Searching for a unique branch in ${{ inputs.target-repo }} containing the string: [$TARGET_FILTER_BRANCH_VERSION]"

          # --- PAGINATION LOGIC to find ALL matching branches ---
          PAGE=1
          ALL_MATCHING_BRANCHES="[]" # Initialize an empty JSON array to store all matches

          while true; do
            echo "[INFO] Fetching page $PAGE of branches..."
            BRANCHES_PAGE=$(curl -s -H "Authorization: token ${{ inputs.pat-token }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ inputs.target-repo }}/branches?per_page=100&page=$PAGE")

            # Break the loop if the API returns an empty list, indicating no more pages
            if [[ $(echo "$BRANCHES_PAGE" | jq 'length') -eq 0 ]]; then
              break
            fi

            # Find branches on the current page that contain the filter string
            MATCHES_ON_PAGE=$(echo "$BRANCHES_PAGE" | jq -r --arg filter "$TARGET_FILTER_BRANCH_VERSION" '[.[] | .name | select(contains($filter))]')

            # Merge the matches from this page into our master list
            ALL_MATCHING_BRANCHES=$(echo "$ALL_MATCHING_BRANCHES $MATCHES_ON_PAGE" | jq -s 'add')

            PAGE=$((PAGE + 1))
          done
          # --- END PAGINATION LOGIC ---

          # Now, perform validation on the complete list of matching branches
          BRANCH_COUNT=$(echo "$ALL_MATCHING_BRANCHES" | jq 'length')
          echo "Found a total of $BRANCH_COUNT matching branches across all pages."

          if [[ "$BRANCH_COUNT" -gt 1 ]]; then
            echo "[Error] More than one branch found matching the filter."
            echo "Found branches: $(echo "$ALL_MATCHING_BRANCHES" | jq -r '. | join(", ")')"
            exit 1
          elif [[ "$BRANCH_COUNT" -eq 0 ]]; then
            echo "[Error] No branches found matching the filter in the entire repository."
            exit 1
          else
            BRANCH_NAME=$(echo "$ALL_MATCHING_BRANCHES" | jq -r '.[0]')
            echo "[INFO] Successfully found unique branch: $BRANCH_NAME"
            echo "branch-ref=$BRANCH_NAME" | tee -a $GITHUB_OUTPUT
          fi

        else
          # MODE 2: Find an exact branch name match.
          # This is the standard case where the source and target branch names are identical.

          TARGET_BRANCH=$(echo ${{ inputs.target-repo-ref }} | sed -E 's|refs/heads/||')
          
          # First, quickly check if the target is the default branch to save API calls
          DEFAULT_BRANCH=$(curl -s -H "Authorization: token ${{ inputs.pat-token }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ inputs.target-repo }}" | \
            jq -r '.default_branch')

          if [[ "$TARGET_BRANCH" == "$DEFAULT_BRANCH" && -n "$TARGET_BRANCH" ]]; then
            echo "[INFO] Target ref matches the default branch [$TARGET_BRANCH] on target repo."
          else
            # If not the default branch, search for an exact match across all pages
            PAGE=1
            BRANCH_NAME=""
            while true; do
              echo "[INFO] Fetching page $PAGE of branches..."
              BRANCHES_PAGE=$(curl -s -H "Authorization: token ${{ inputs.pat-token }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/${{ inputs.target-repo }}/branches?per_page=100&page=$PAGE")

              if [[ $(echo "$BRANCHES_PAGE" | jq 'length') -eq 0 ]]; then
                break
              fi

              FOUND_ON_PAGE=$(echo "$BRANCHES_PAGE" | jq -r --arg filter "$TARGET_BRANCH" '.[] | .name | select(. == $filter)')

              if [[ -n "$FOUND_ON_PAGE" ]]; then
                BRANCH_NAME="$FOUND_ON_PAGE"
                break
              fi
              PAGE=$((PAGE + 1))
            done

            if [[ -z "$BRANCH_NAME" ]]; then
              echo "[Error] No branches found matching [$TARGET_BRANCH] in the entire repository."
              exit 1
            else
              echo "[INFO] Successfully found branch [$BRANCH_NAME] at target repo."
            fi
          fi
          
          # Set the output for other jobs to use the original, unmodified ref
          echo "branch-ref=${{ inputs.target-repo-ref }}" | tee -a $GITHUB_OUTPUT
        fi

    - uses: actions/checkout@v4
      with:
        repository: ${{ inputs.target-repo }}
        token: ${{ inputs.pat-token }}
        persist-credentials: false # otherwise, the token used is the GITHUB_TOKEN, instead of your personal access token.
        fetch-depth: 0 # otherwise, there would be errors pushing refs to the destination repository.
        ref: ${{ steps.filter-branch.outputs.branch-ref }}

    - name: convert yaml to props config
      run: |
        ${{ github.action_path }}/../../scripts/generic-store-version-as-config-in-git.sh \
          "${{ inputs.yaml-store-path-key }}" \
          "${{ inputs.yaml-env-list-query-path }}" \
          "${{ inputs.target-yaml-config-file }}" \
          "${{ inputs.artifact-base-name }}" \
          "${{ inputs.artifact-version }}" \
          "${{ inputs.target-repo }}" \
          "${{ inputs.create-if-new-config }}" \
          "${{ inputs.pat-token }}" \
          "${{ inputs.search-list-match-value }}" \
          "${{ inputs.search-list-yaml-post-query }}" \
          "${{ inputs.target-multi-yaml-config-files }}" \
          "${{ inputs.strict-update }}"
      shell: bash
       
    - name: Push changes
      if: inputs.git-push == 'true'
      uses: partior-libs/gjs-github-push@partior-stable
      with:
        repository: ${{ inputs.target-repo }}
        github_token: ${{ inputs.pat-token }}
        branch: ${{ steps.filter-branch.outputs.branch-ref }}

    - run: echo Done storing version
      shell: bash
